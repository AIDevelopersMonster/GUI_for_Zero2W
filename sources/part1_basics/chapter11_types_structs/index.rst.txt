Глава 11: Пользовательские Типы Данных и Структуры
===================================================

В этой главе мы глубоко погрузимся в мир **пользовательских типов данных** в языке Си. Мы изучим мощные конструкции, такие как ``typedef``, ``enum``, ``struct`` и ``union``, которые позволяют создавать более **читаемый**, **безопасный** и **структурированный** код. Это особенно важно при разработке масштабируемых и сложных приложений.

.. contents::
   :local:
   :depth: 2

---

1. Тип ``typedef``: Псевдонимы для Существующих Типов
------------------------------------------------------

``typedef`` — это ключевое слово, которое позволяет вам создать **новое, более удобное имя (псевдоним)** для уже существующего типа данных. Это особенно полезно для упрощения длинных или сложных объявлений типов, а также для повышения читаемости кода.

Основное Использование
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: c

    // Создаем псевдоним 'uint' для типа 'unsigned int'
    typedef unsigned int uint;

    uint a = 5; // Теперь 'uint' можно использовать как обычный тип данных
    uint b = 10;
    printf("a + b = %u\n", a + b);

``typedef`` со Структурами
^^^^^^^^^^^^^^^^^^^^^^^^^^

``typedef`` часто используется в сочетании со структурами, чтобы избежать повторного написания ключевого слова ``struct``.

.. code-block:: c

    // Объявление структуры Point и создание псевдонима Point для нее
    typedef struct {
        int x;
        int y;
    } Point; // 'Point' теперь является псевдонимом для этой анонимной структуры

    Point p1 = {1, 2};
    Point p2 = {3, 4};
    printf("Point p1: (%d, %d)\n", p1.x, p1.y);

Зачем нужен ``typedef``?
^^^^^^^^^^^^^^^^^^^^^^^^

* **Читаемость**: Делает код более понятным, особенно с комплексными типами.
* **Портативность**: Позволяет легко изменять базовый тип, не меняя весь код (например, ``typedef long int large_integer;``).
* **Согласованность**: Помогает поддерживать единый стиль именования типов.

---

2. Перечисления ``enum``: Именованные Константы
-----------------------------------------------

Перечисления (``enum``) позволяют вам определить **набор именованных целочисленных констант**. Это делает код более самодокументируемым и менее подверженным ошибкам, чем использование "магических чисел".

Базовое Объявление
^^^^^^^^^^^^^^^^^^

По умолчанию, первое значение в ``enum`` равно ``0``, последующие увеличиваются на ``1``.

.. code-block:: c

    enum Color { RED, GREEN, BLUE }; // RED=0, GREEN=1, BLUE=2

    enum Color favorite_color = GREEN; // Присваиваем одно из именованных значений
    printf("Favorite color (enum value): %d\n", favorite_color); // Выведет 1

    if (favorite_color == RED) {
        printf("Color is Red\n");
    } else if (favorite_color == GREEN) {
        printf("Color is Green\n");
    }

Явные Значения
^^^^^^^^^^^^^^

Вы можете явно задать значения для констант. Если значение не указано, оно продолжает последовательность.

.. code-block:: c

    enum Status { OK = 0, WARNING = 1, ERROR = 100, CRITICAL }; // CRITICAL будет 101

    enum Status current_status = ERROR;
    printf("Current status (enum value): %d\n", current_status); // Выведет 100

    enum Status another_status = CRITICAL;
    printf("Another status (enum value): %d\n", another_status); // Выведет 101

Зачем нужен ``enum``?
^^^^^^^^^^^^^^^^^^^^^

* **Читаемость**: Использование ``RED`` вместо ``0`` значительно улучшает понимание кода.
* **Безопасность**: Компилятор может предупредить о некорректных присваиваниях, если они выходят за рамки перечисления (хотя в C это не так строго, как в C++).
* **Удобство**: Легко добавлять новые константы без изменения числовых значений по всему коду.

---

3. Структуры ``struct``: Объединение Разных Типов
-------------------------------------------------

Структуры (``struct``) — это мощная возможность Си, позволяющая **объединять переменные разных типов данных в одну логическую единицу**. Каждая переменная внутри структуры называется **членом** (или полем).

Объявление и Инициализация
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: c

    // Объявление структуры Person
    struct Person {
        char name[50]; // Массив символов для имени
        int age;       // Целое число для возраста
        float height;  // Число с плавающей точкой для роста
    };

    // Инициализация переменной структуры
    struct Person user = {"Alice", 30, 1.75f};

    // Доступ к членам структуры через оператор точки '.'
    printf("User Name: %s\n", user.name);
    printf("User Age: %d\n", user.age);
    printf("User Height: %.2f meters\n", user.height);

Структуры с ``typedef`` (Рекомендуемый подход)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Как уже упоминалось, ``typedef`` часто используется со структурами для создания более чистого синтаксиса.

.. code-block:: c

    // Объявление и псевдоним для структуры Complex
    typedef struct {
        float real; // Действительная часть
        float imag; // Мнимая часть
    } Complex; // 'Complex' теперь является типом

    Complex z1 = {1.0, 2.5};
    Complex z2;
    z2.real = 3.0;
    z2.imag = -1.5;

    printf("Complex z1: %.1f + %.1fi\n", z1.real, z1.imag);
    printf("Complex z2: %.1f + %.1fi\n", z2.real, z2.imag);

Вложенные Структуры
^^^^^^^^^^^^^^^^^^^^

Структуры могут содержать другие структуры в качестве своих членов.

.. code-block:: c

    typedef struct {
        int day;
        int month;
        int year;
    } Date;

    typedef struct {
        char title[100];
        char author[50];
        Date publish_date; // Член структуры Date
    } Book;

    Book my_book = {"The C Programming Language", "Dennis Ritchie", {2, 4, 1978}};

    printf("Book: %s by %s, published on %d/%d/%d\n",
           my_book.title, my_book.author,
           my_book.publish_date.day, my_book.publish_date.month, my_book.publish_date.year);

Зачем нужны ``struct``?
^^^^^^^^^^^^^^^^^^^^^^^

* **Моделирование Реальных Сущностей**: Позволяют группировать связанные данные, которые логически относятся к одному объекту (например, человек, машина, дата).
* **Организация Кода**: Улучшают структуру программы, делая ее более модульной.
* **Передача Данных**: Упрощают передачу нескольких связанных значений в функции и из функций.

---

4. Объединения ``union``: Совместное Использование Памяти
---------------------------------------------------------

``union`` (объединение) — это специальный тип данных, который позволяет **нескольким полям (членам) использовать одну и ту же область памяти**. Это означает, что в любой момент времени только **один** из членов объединения может хранить значение. ``union`` полезен для экономии памяти, когда вы знаете, что вам нужно хранить данные только одного из нескольких возможных типов в определенный момент.

Объявление и Использование
^^^^^^^^^^^^^^^^^^^^^^^^^^

Размер ``union`` равен размеру самого большого члена.

.. code-block:: c

    union Data {
        int i;        // Целое число
        float f;      // Число с плавающей точкой
        char str[20]; // Массив символов (строка)
    };

    union Data data; // Объявление переменной объединения

    // Присваиваем значение int
    data.i = 10;
    printf("Data as int: %d\n", data.i); // Выведет 10
    // Если теперь мы попытаемся прочитать data.f или data.str, то получим мусор,
    // так как область памяти была переписана для int.

    // Присваиваем значение float (перезаписывает предыдущее значение int)
    data.f = 2.5f;
    printf("Data as float: %.1f\n", data.f); // Выведет 2.5

    // Присваиваем значение string (перезаписывает предыдущее значение float)
    strcpy(data.str, "Hello Union!"); // Для строк используем strcpy
    printf("Data as string: %s\n", data.str); // Выведет "Hello Union!"

Осторожность при Использовании ``union``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Использование ``union`` требует большой осторожности, так как вы должны **точно знать, какой член в данный момент активен** (то есть, какой член содержит актуальные данные). Обычно ``union`` используется в сочетании со ``struct``, где структура содержит член ``enum`` (или другой индикатор), который указывает, какой член ``union`` является действующим.

.. code-block:: c

    // Пример использования struct и union вместе (таггированное объединение)
    typedef enum { INT_TYPE, FLOAT_TYPE, STRING_TYPE } DataType;

    typedef struct {
        DataType type; // Индикатор, какой тип данных активен в union
        union {
            int i_val;
            float f_val;
            char s_val[50];
        } value; // Имя для поля union
    } MyVariant;

    MyVariant v1;
    v1.type = INT_TYPE;
    v1.value.i_val = 123;
    printf("Variant 1 (int): %d\n", v1.value.i_val);

    MyVariant v2;
    v2.type = STRING_TYPE;
    strcpy(v2.value.s_val, "Variant String");
    printf("Variant 2 (string): %s\n", v2.value.s_val);

Зачем нужен ``union``?
^^^^^^^^^^^^^^^^^^^^^^

* **Экономия Памяти**: Самая главная причина. Когда у вас есть данные, которые могут быть одного из нескольких типов, но только один из них будет активен в любой момент.
* **Низкоуровневые Операции**: Используется в системном программировании для интерпретации одной и той же области памяти как разных типов (например, для разбора сетевых пакетов).

---

5. Примеры Взаимодействия и Ожидаемый Вывод
--------------------------------------------

Давайте соберем некоторые из изученных концепций в один рабочий пример.

.. code-block:: c

    #include <stdio.h> // Для printf
    #include <string.h> // Для strcpy

    // Используем typedef для создания псевдонима Item для нашей структуры
    typedef struct {
        int id;
        char name[20];
        float price;
    } Item;

    // Используем enum для категорий товаров
    enum Category { ELECTRONICS, BOOKS, CLOTHING, FOOD };

    // Структура для товара с использованием enum и вложенной структуры
    typedef struct {
        Item details; // Вложенная структура Item
        enum Category category;
        int quantity;
    } InventoryItem;

    int main() {
        // Создаем экземпляр Item
        Item item1 = {1, "Laptop", 1200.50f};
        printf("Item Details: ID: %d, Name: %s, Price: %.2f\n", item1.id, item1.name, item1.price);

        // Создаем экземпляр InventoryItem
        InventoryItem inv_item;
        inv_item.details.id = 101;
        strcpy(inv_item.details.name, "Novel 'C Master'");
        inv_item.details.price = 25.99f;
        inv_item.category = BOOKS; // Используем enum константу
        inv_item.quantity = 50;

        printf("\nInventory Item Details:\n");
        printf("  ID: %d\n", inv_item.details.id);
        printf("  Name: %s\n", inv_item.details.name);
        printf("  Price: %.2f\n", inv_item.details.price);
        printf("  Category (enum value): %d\n", inv_item.category);
        printf("  Quantity in Stock: %d\n", inv_item.quantity);

        // Пример использования typedef для базового типа
        typedef int counter_t;
        counter_t total_count = 1000;
        printf("\nTotal Count: %d\n", total_count);

        return 0;
    }

**Ожидаемый вывод:**

.. code-block:: text

    Item Details: ID: 1, Name: Laptop, Price: 1200.50

    Inventory Item Details:
      ID: 101
      Name: Novel 'C Master'
      Price: 25.99
      Category (enum value): 1
      Quantity in Stock: 50

    Total Count: 1000

---

6. Компиляция и Запуск Примеров
--------------------------------

Чтобы скомпилировать и запустить ваш код на Си:

1.  **Сохраните код** в файл, например, ``types_and_structs.c``.
2.  **Откройте терминал** или командную строку.
3.  **Используйте компилятор GCC** (GNU C Compiler):

    .. code-block:: bash

        gcc types_and_structs.c -o types_and_structs

    * ``gcc``: Команда для вызова компилятора.
    * ``types_and_structs.c``: Имя вашего исходного файла на Си.
    * ``-o types_and_structs``: Указывает, что исполняемый файл должен быть назван ``types_and_structs``.

4.  **Запустите скомпилированную программу**:

    .. code-block:: bash

        ./types_and_structs

---

7. Дополнительные Ресурсы
--------------------------

Для более глубокого изучения этих тем рекомендуем обратиться к следующим источникам:

* `Документация Cppreference`_: (раздел про ``struct`` охватывает также ``typedef`` и ``union``). Ищите соответствующие разделы для ``enum``.

.. _Документация Cppreference: https://en.cppreference.com/w/c/language/struct

---

``typedef``, ``enum``, ``struct`` и ``union`` являются важными строительными блоками языка Си. Их освоение значительно улучшит вашу способность проектировать сложные структуры данных и создавать эффективные, хорошо организованные программы, особенно при разработке API и взаимодействии с системными библиотеками.