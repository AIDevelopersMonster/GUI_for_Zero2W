#include <gtk/gtk.h>    // Включаем заголовочный файл для библиотеки GTK+ (для создания графического интерфейса пользователя)
#include <stdlib.h>     // Включаем заголовочный файл для стандартных функций, таких как system() и snprintf()
#include <stdio.h>      // Включаем заголовочный файл для snprintf() - используется для форматирования строки команды

// --- Функции управления сервоприводом ---

/**
 * @brief Устанавливает положение сервопривода, отправляя команду через pigs.
 * @param pulsewidth Ширина импульса в микросекундах (обычно от 500 до 2500 для SG90).
 * 1500 us обычно соответствует центральному положению.
 */
void set_servo(int pulsewidth) {
    char cmd[64]; // Создаем буфер для хранения строки команды.
                  // Достаточно большой для команды "pigs s 17 2500" и завершающего нуля.

    // Форматируем строку команды: "pigs s 17 [pulsewidth]".
    // "pigs s" - команда pigs для установки ширины импульса (серво).
    // "17" - номер GPIO-пина, к которому подключен сервопривод (GPIO17).
    // "%d" - placeholder для значения pulsewidth.
    snprintf(cmd, sizeof(cmd), "pigs s 17 %d", pulsewidth);

    // Выполняем команду в системной оболочке.
    // Это запускает внешний инструмент 'pigs', который управляет сервоприводом.
    // Важно: для работы 'pigs' должен быть запущен демон pigpiod, и у пользователя должны быть права.
    system(cmd);
}

// --- Функции обратного вызова для GUI (GTK+) ---

/**
 * @brief Функция обратного вызова, вызываемая при нажатии одной из кнопок управления сервоприводом.
 * @param widget Указатель на виджет, вызвавший событие (в данном случае GtkButton).
 * @param data Пользовательские данные, переданные при подключении сигнала (здесь - целевая ширина импульса).
 */
void on_button_clicked(GtkWidget *widget, gpointer data) {
    // Преобразуем gpointer (обобщенный указатель) обратно в int (ширину импульса).
    int value = GPOINTER_TO_INT(data);
    // Устанавливаем положение сервопривода.
    set_servo(value);
}

/**
 * @brief Функция обратного вызова, вызываемая при изменении положения ползунка (GtkScale).
 * @param range Указатель на GtkRange (базовый тип для GtkScale), вызвавший событие.
 * @param user_data Пользовательские данные (не используются в данной функции, NULL).
 */
void on_scale_moved(GtkRange *range, gpointer user_data) {
    // Получаем текущее значение ползунка.
    int value = (int)gtk_range_get_value(range);
    // Устанавливаем положение сервопривода на основе значения ползунка.
    set_servo(value);
}

// --- Главная функция программы ---

/**
 * @brief Точка входа в программу. Инициализирует GTK+, создает графический интерфейс
 * и запускает основной цикл обработки событий.
 * @param argc Количество аргументов командной строки.
 * @param argv Массив строк аргументов командной строки.
 * @return Код завершения программы (0 при успешном выполнении, 1 при ошибке).
 */
int main(int argc, char *argv[]) {
    // Инициализация библиотеки GTK+. Должна быть вызвана первой для любого GTK-приложения.
    gtk_init(&argc, &argv);

    // --- Создание главного окна GTK+ ---
    GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); // Создаем новое окно верхнего уровня.
    gtk_window_set_title(GTK_WINDOW(window), "Servo SG90 Controller"); // Устанавливаем заголовок окна.
    gtk_window_set_default_size(GTK_WINDOW(window), 400, 200); // Устанавливаем размер окна по умолчанию.
    // Устанавливаем иконку окна из файла. Путь должен быть абсолютным или относительным к месту запуска.
    gtk_window_set_icon_from_file(GTK_WINDOW(window), "/home/Alex/GUI4RPiZ2W/5/servo_gui.png", NULL);
    // Подключаем сигнал "destroy" (закрытие окна) к функции gtk_main_quit.
    // Это гарантирует, что приложение завершится при закрытии окна.
    g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit), NULL);

    // --- Создание вертикального контейнера (VBox) ---
    // GtkBox - это контейнер, который упорядочивает виджеты в одном измерении (вертикально или горизонтально).
    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10); // Создаем вертикальный контейнер с отступом 10 пикселей между дочерними элементами.
    gtk_container_add(GTK_CONTAINER(window), vbox); // Добавляем этот контейнер в главное окно.

    // --- Создание горизонтального контейнера (HBox) для кнопок ---
    GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5); // Создаем горизонтальный контейнер с отступом 5 пикселей.
    // Упаковываем HBox в VBox. FALSE, FALSE, 0 означает: не растягивать, не заполнять, без дополнительного отступа.
    gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);

    // --- Определение данных для кнопок ---
    // Это анонимная структура и массив для удобного создания кнопок.
    struct {
        const char *label; // Текст метки кнопки
        int value;         // Значение ширины импульса, которое будет отправлено сервоприводу при нажатии кнопки
    } buttons[] = {
        {"<<", 500},   // Полностью влево
        {"<", 1000},   // Немного влево
        {"Center", 1500}, // Центр
        {">", 2000},   // Немного вправо
        {">>", 2500}    // Полностью вправо
    };

    // --- Создание и подключение кнопок ---
    for (int i = 0; i < 5; i++) {
        GtkWidget *btn = gtk_button_new_with_label(buttons[i].label); // Создаем кнопку с заданной меткой.
        // Подключаем сигнал "clicked" кнопки к функции on_button_clicked.
        // GINT_TO_POINTER преобразует целочисленное значение (ширину импульса) в указатель,
        // который будет передан в on_button_clicked через 'data'.
        g_signal_connect(btn, "clicked", G_CALLBACK(on_button_clicked), GINT_TO_POINTER(buttons[i].value));
        // Упаковываем кнопку в горизонтальный контейнер.
        // TRUE, TRUE - кнопка будет растягиваться и заполнять доступное пространство.
        // 0 - без дополнительного отступа.
        gtk_box_pack_start(GTK_BOX(hbox), btn, TRUE, TRUE, 0);
    }

    // --- Создание ползунка (GtkScale) ---
    // Создаем горизонтальный ползунок с диапазоном значений от 500 до 2500
    // и шагом изменения значения 10.
    GtkWidget *scale = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL, 500, 2500, 10);
    gtk_scale_set_value_pos(GTK_SCALE(scale), GTK_POS_TOP); // Размещаем текущее значение ползунка сверху.
    // Подключаем сигнал "value-changed" (изменение значения ползунка) к функции on_scale_moved.
    // NULL в user_data, так как значение берется напрямую из ползунка в on_scale_moved.
    g_signal_connect(scale, "value-changed", G_CALLBACK(on_scale_moved), NULL);
    gtk_range_set_value(GTK_RANGE(scale), 1500); // Устанавливаем начальное значение ползунка в 1500 (центр).
    // Упаковываем ползунок в вертикальный контейнер.
    // TRUE, TRUE - ползунок будет растягиваться и заполнять доступное пространство.
    // 0 - без дополнительного отступа.
    gtk_box_pack_start(GTK_BOX(vbox), scale, TRUE, TRUE, 0);

    // --- Отображение GUI и запуск основного цикла GTK+ ---
    gtk_widget_show_all(window); // Отображает все виджеты, содержащиеся в окне.
    gtk_main(); // Запускает основной цикл обработки событий GTK+.
                // Программа будет работать, пока gtk_main_quit() не будет вызвана.

    return 0; // Возвращаем 0, указывая на успешное завершение программы.
}